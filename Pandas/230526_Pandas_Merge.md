# Pandas - Merge

## merge() : 데이터 병합  

두 개의 데이터프레임의 서로 공통되는 열 또는 행을 기준으로 두 개의 데이터프레임을 하나로 병합  
이 때 공통되는 열을 key라고 한다.  

merge 함수를 사용하는데는 두 가지 방식이 있다.  

- `df1.merge(df2, how)`
- `pd.merge(df1, df2, how)` 

how 매개변수에는 **병합 방식**을 적어준다.  
병합 방식에는 크게 inner 와 outer 두 가지가 있고,  
outer경우 다시 left와 right으로 나뉜다.  

- `how = 'inner'` : key값이 동일한 데이터만 포함한다. (default)
- `how = 'outer'` : 두 데이터프레임의 모든 값을 포함한다.   
서로의 데이터프레임에 존재하지 않는 값은 `NaN`값으로 처리된다.  
- `how = 'left'` : 왼쪽 데이터프레임을 기준으로 모든 값을 포함한다.  
오른쪽 데이터프레임에 값이 존재하지 않으면 `NaN`으로 처리된다. 
- `how = 'right'` : 오른쪽 데이터프레임을 기준으로 모든 값을 포함한다.  
왼쪽 데이터프레임에 값이 존재하지 않으면 `NaN`으로 처리된다.  

**Pandas의 merge 함수의 경우 key값을 따로 매개변수로 지정해주지 않아도 자동으로 찾아준다!**  

그래서 데이터프레임의 key 값이 같은 데이터가 여러 개 있는 경우,  
가능한 모든 경우의 수를 따져서 조합해서 만들어 낸다.  

---

### on 기준열 명시  

두 개의 데이터프레임에서 이름이 같은 열은 모두 key값이 되는데, (공통 열)  
이름은 같지만 key로는 사용할 수 없는 열이 존재한다.  
이 때는, `on=` 매개변수를 사용하여 기준열을 직접 지정해줄 수 있다.  

`pd.merge(df1, df2, on, how)`  

on 매개변수의 인수로 넣어준 기준 열 외에 같은 이름의 열이 있는 경우,  
'열이름_x', '열이름_y'로 열 이름이 변경되어서 결과 값이 반환된다.  

### left_on, right_on  

key가 되는 기준열의 이름이 다른 경우,  
left_on, right_on 인수를 사용해서 양쪽 데이터프레임의 기준열을 명시해준다.  

즉, 왼쪽의 데이터프레임의 열과 오른쪽 데이터프레임의 열이 같다고 지정해주는 것이다.  
예제는 아래와 같다.  

`pd.merge(df1, df2, left_on='이름', right_on='성명', how='outer')`  

---

### left_index, right_index : 인덱스를 key값으로 사용  

기존에는 공통된 열을 key값으로 사용해서 데이터프레임을 병합해줬다면,  
인덱스를 사용해서 병합하는 것도 가능하다.  

왼쪽 데이터프레임의 인덱스를 사용하는 경우에는 `left_index=True`  
오른쪽 데이터프레임의 인덱스를 사용하는 경우에는 `right_index=True` 값을 지정해준다.  

만약 왼쪽 데이터프레임에서는 key 값으로 열을,  
오른쪽 데이터프레임에서는 key 값으로 인덱스를 사용한다면,  
위의 `on` 매개변수와 `index` 매개변수를 함께 사용하는 것이 가능하다.  
ex) `left_on = col, right_index=True`  

만약 한 쪽의 데이터프레임의 멀티 인덱스를 key 값으로 사용하는 경우에는,  
다른 쪽의 데이터프레임의 열에 해당하는 key 값을 [] 대괄호로 묶어 여러 개의 열을 지정해줄 수 있다.  

---

### Multi Index 사용시 원소 접근 법  

멀티 인덱스 (= 계층적 인덱스, 다중 인덱스) 를 사용할 시 원소에 접근하려면,  
. 연산자를 이용해 연속적으로 이어줘야 한다. (체인 인덱싱)  

`df.loc['row1'].loc['row1-2']['col']`  
-> 이렇게 loc 인덱서를 이용해서 특정 행 값에 접근한 다음 열을 지정해줘서 원소에 접근하는 방법도 있고,  

`df.iloc[위치 인덱스]['col']`  
-> iloc을 이용해서 해당 행의 0-base 위치 인덱스를 이용해 접근하는 방법도 있다!  

---

### 난수 발생시켜서 데이터프레임 생성하기  

`np.arange(12).reshape((5,2))`  

Numpy의 `arange()` 이용해서 N개의 난수 생성,  
`reshape()` 이용해서 i행 j열 의 데이터프레임 형식 지정.  

---

## join() : 인덱스 사용 병합  

`df1.join(df2, on=None, how='left', lsuffix='', rsuffix='', sort=False)`  

- `pd.join()`의 형태가 아니라, `df.join()`의 형태를 사용한다.  
- `on=None` : 기준 설정 
- `lsuffix='', rsuffix=''` : 동일한 이름의 열에 붙일 접미사 지정  
- `sort=False` : 정렬 여부 지정  

만약, 열을 기준으로 병합하고 싶은데 join 메서드를 쓰려면, 
`set_index`를 이용해서 열을 인덱스로 바꿔준다음 사용한다.  

---

## concat() : 데이터 연결 (시리즈, 데이터프레임)  

`pd.concat([df1, df2], axis=, join=, ignore_index=, keys=)`

- 기준열을 사용하지 않고 단순하게 데이터를 연결하는 작업만 수행  
- 기본적으로 위/아래로 데이터프레임의 행을 연결한다 (`axis=0`이 default)
- `axis=1` 로 설정할 경우, 옆으로 결합한다. (열 결합)
- 두 개의 시리즈, 혹은 데이터프레임을 연결하기 때문에  
**인덱스 값이 중복될 수 있다!** 
- 위의 경우에 대비해서 사용할 수 있는 매개변수가 `ignore_index`이다.  
인수를 `False`로 줄 경우, 기존의 인덱스 값을 유지하고,  
인수를 `True`로 줄 경우, 기존의 인덱스 값을 무시하고 다시 0-base의 위치 인덱스를 생성한다.  
- `join='outer'/'inner'` : outer는 합집합, inner는 교집합을 말한다.   
'outer'가 default이다.
- `keys=None` : 멀티 인덱스를 사용하는 경우 keys 파라미터를 지정해준다.  
부여해줄 멀티 인덱스를 리스트의 형태로 넣어준다.  
ex) `pd.concat([s1, s2], keys=['x', 'y'])`

**반드시 연결할 두 데이터셋을 [] 리스트의 형태로 묶어서 하나의 인수로 만들어서 넣어준다!**  

*keys 파라미터는 보통 연결할 두 데이터 셋의 인덱스가 중복될 경우,  
첫번째 데이터셋에 통째로 멀티인덱스를 하나 부여해주고,  
두번째 데이터셋에 통째로 멀티인덱스를 하나 넣어줘서 중복의 충돌을 피하기 위함이다.*

*join 파라미터의 경우, axis가 행 방향으로 설정되어있으면 inner는 공통된 열에 대해서만 연결하고,  
axis가 열 방향으로 설정되어있으면 inner는 공통된 행에 대해서만 연결한다.*  


