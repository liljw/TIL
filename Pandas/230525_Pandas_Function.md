# Pandas - Function

Pandas에서 사용 가능한 함수(메서드)들에 대해서 배워보자.  

- `count()` : 데이터 개수 반환
- `value_counts()` : 데이터 빈도 수 반환
- `sort_index()` : 인덱스를 기준으로 정렬
- `sort_values()` : 데이터 값을 기준으로 정렬
- `dropna()` : 결측값 제거
- `fillna()` : 결측값을 다른 값으로 대체
- `apply()` : 동일한 반복 연산에 함수 적용
- `cut()` : 데이터 구간 분할
- `qcut()` : 경계 지정 없이 데이터를 일정 구간으로 분할
- `set_index()` : 열로 인덱스 설정
- `reset_index()` : 인덱스 제거하고 열로 추가
- `rename()` : 열 또는 행 인덱스 이름 변경

---

## count() : 데이터 개수 반환

데이터프레임의 경우, 각 열의 원소의 개수 반환
**NaN은 세지 않는다!!**   
-> NaN 포함한 개수를 세려면 `len()` 함수 사용.  

- `np.random.randint(N)` : 0 ~ N-1 사이의 난수 발생  
    - `size=N` : 난수 발생 개수 지정하는 매개변수 

- `np.random.seed(N)` : seed 값을 고정해서 난수 고정

난수로 데이터프레임 만들기  
`df = pd.DataFrame(np.random.randint(5, size=(4,4)))`  
-> 0 ~ 4 사이의 정수로 4행 4열의 데이터프레임 생성  

그 중, 2행 3열의 값을 np.nan 으로 바꾸면,  
df.count() 를 적용했을 때  
각 열의 원소의 개수를 반환하므로, (4,4,4,3)의 결과값이 반환된다.  

---

## 특정 패키지에서 데이터셋 불러오기, 저장하기  

- `import seaborn as sns` : seaborn 모듈 import  
- `titanic = sns.load_dataset('titanic')` : seaborn 모듈 내에 titanic 데이터 로드  
- `titanic.to_csv('data/titanic.csv')` : titanic 데이터프레임을 csv 파일로 저장

--- 

## value_counts() : 데이터 빈도 수 반환

카테고리의 값을 세는 것과 비슷하다!  

시리즈의 값이 정수, 문자열 등 카테고리 값인 경우에  
`series.value_counts()` 메서드를 사용해서 각각의 값이 나온 횟수를 구할 수 있다.  

value_counts() 함수 내에 쓸 수 있는 파라미터들은 다음과 같다.
- `dropna=True` : NaN을 포함하지 않고 개수 카운팅 (default)
- `dropna=False` : NaN을 포함하고 개수 카운팅  
- `ascending=True` : 오름차순 정렬 (default는 False로 내림차순 정렬된다)
- `normalize=True` : 전체 빈도 수에서의 해당 범주형 데이터의 빈도의 비율을 계산 
    - normalize 한 값에 *100 을 하면 백분율이 된다!

앞에 `pd.DataFrame()`을 씌워주면 value_counts()의 결과값을 데이터프레임 형태로 출력 가능하다!  

**value_counts() 의 인수로 여러 개의 column을 넣을 수 있다!!!!**  
-> 이 경우 데이터프레임 형태로 반환하면 멀티 인덱스로 추출된다.  

---

## sort_index(), sort_values() : 정렬 함수  

- `sort_index()` : 인덱스를 기준으로 정렬
- `sort_values()` : 값(특정 열)을 기준으로 정렬

`ascending = True/False` 매개변수 두 함수 모두 적용 가능.  
기본값은 True(오름차순)으로 설정되어있다.  

데이터프레임에 `sort_values()`를 적용시켜 정렬하는 경우,  
반드시 `by=` 매개변수, 즉 기준열을 넣어줘야 한다!   

기준열은 여러 개를 지정해 줄 수 있다.  
예를 들어 `df.sort_values(by=[col1, col2], ascending=False)`  
위의 함수처럼 여러 개의 기준 열을 by 매개변수의 인수로 넣어주면,  
col1 을 기준으로 1차 정렬, 그리고 col2를 기준으로 2차 정렬된다.  
기준 열을 여러 개 설정해줄 때는 리스트([])로 묶어준다.  

---

## sum() : 행, 열 합계  

주의할 점은, 해당 함수는 Pandas의 인스턴스 메서드이다!!  
일반 파이썬 문법에서 적용되는 함수가 아니므로 주의하자.  

행, 또는 열을 지정해줘야 하는데,  
`axis=0/1` 매개변수로 지정해준다.  
0은 열 방향, 1은 행 방향을 의미한다.  (default는 axis=0, 열 방향이다)  

보통 파생변수(가공열)을 만들 때 많이 사용한다!  

이 외에도 각 행, 열의 [평균, 최댓값, 최솟값]을 구하는 메서드들은 아래와 같으며,  
`sum()` 메서드와 동일하게 axis 매개변수로 행, 열 방향을 지정해준다.   
- `df.mean()` : 평균 
- `df.min()` : 최솟값
- `df.max()` : 최댓값  

---

## dropna(), fillna() : 결측값 처리 함수  

- `df.dropna(axis=0/1)` : `NaN`값이 있는 행 또는 열을 삭제
    - inplace=True 매개변수를 넣지 않으면 원본 반영되지 않는다!  
- `df.fillna(0)` : `NaN` 값을 ()안의 값으로 대체
    - 마찬가지로 inplace없으면 원본 반영되지 않는다.  

**주의!!! 여기서 axis 값은 0이 행 방향(default), 1이 열 방향이다!!**

---

## apply() : 열 또는 행에 동일한 함수 적용  

`df.apply(func, axis=0/1)`  
- 데이터프레임의 행이나 열에 복잡한 반복 연산을 수행하는 메서드.
- 연산은 반드시 함수 형태이어야 한다. 
- lambda 함수 사용 가능
- axis 매개변수는 0이 열, 1이 행 방향으로 적용된다.  (default는 0, 열 방향)
- 적용되는 함수가 행, 열에 적용되는 게 아니라 값 자체에 적용되는 함수일 경우,  
axis값에 상관없이 동일한 결과가 출력된다.  

**apply()는 데이터프레임에 사용한다! Series에서는 map()을 사용한다.**  

lambda 함수 + apply() 사용 예제  
`df.apply(lambda x : x.max() - x.min(), axis=0/1)`

`series.map(func)` 의 경우 map 메서드 내에 series에 적용될 함수를 넣어주면 된다.  

--- 

### 데이터프레임 for문 이용하기 

```py
for i in df:
    print(i)
```

위의 코드의 결과는 df의 column들을 출력한 것과 같다.  
즉, 데이터프레임을 for 문으로 돌릴 때는 df를 그대로 넣으면 column이 하나씩 추출된다.  

---

## cut(), qcut() : 데이터 구간 분할  

데이터의 값의 크기를 기준으로 구간 분할하여 카테고리 값으로 변환하는데 사용된다.  

`pd.cut(data, bins, labels)`
- `data=` : 구간을 나눌 실제 데이터 값 (관측값)
- `bins=` : 카테고리로 나누는 기준 설정 (구간 경계값)
- `labels=` : 각 구간의 이름 (카테고리 명)
    - labels의 순서는 bins에 들어가는 구간의 순서와 동일해야한다.  

반환되는 결과값의 타입은 Pandas의 array중 categorical 데이터이다.  

반환되는 결과값에 `.categories` 속성을 이용하면  
해당 결과값의 카테고리 값(인덱스)를 얻을 수 있다.  

또한, 결과괎에 `.code` 속성을 이용하면 정수로 인코딩된 카테고리 값을 얻을 수 있다.  
*주의할 점은, `NaN`값의 경우 -1로 처리된다.*  

**이렇게 cut()을 이용해서 얻은 카테고리 값은 list(result)의 형태를 이용하여  
매개변수로 넣어줬던 data와 pd.DataFrame으로 결합시켜서 결과를 얻을 수 있다.**   

구간 경계선을 따로 지정하지 않고도 나눌 수 있는 함수가 있다.  
`qcut()`을 이용하면 구간 경계선을 지정하지 않고도 데이터가 동일한 구간으로 분할된다.  

`pd.qcut(data, 구간수, labels)`
- 구간수에는 첫번째 매개변수에 들어간 데이터를 총 몇 개의 구간으로 나눌지 정수값을 입력해준다.  
- 마찬가지로 labels에 들어가는 리스트의 길이는 구간수와 동일해야한다!  

cut과 마찬가지로 기존의 데이터와 결합해서 새로운 파생변수(가공열)을 만드는데 많이 쓰인다.  

*그리고 qcut의 경우 데이터내에 동일한 값(중복값)이 존재할 경우 구간의 수가 달라질 수 있다.*  

---

## set_index(), reset_index() : 인덱스 설정  

기존의 열을 인덱스로, 인덱스를 열로 바꿔주는데 쓰이는 메서드이다.  

- `set_index()` : 기존의 행 인덱스를 제거, 특정 열을 인덱스로 설정  
    - `inplace=True` 값을 주기 전에는 원본에 반영되지 않는다.  
- `reset_index()` : 기존의 인덱스를 다시 열로 올리고, 0-base 위치 인덱스로 변경
    - 마찬가지로 inplace 매개변수 사용해줘야 원본에 반영된다.  
    - **`drop=True`를 사용하면, 기존 인덱스를 다시 열로 올리지 않고, 그냥 버린다!!**


### rename() : 인덱스 이름 변경  

- `rename(index={현재 index : 새 index})` : 행 인덱스 이름 변경
- `rename(columns={현재 column : 새 column})` : 열 인덱스 이름 변경

rename의 경우에도 inplace 파라미터가 적용된다.  

**단순히 순서를 바꾸거나, 순서를 바꾸면서 컬럼명도 변경하고 싶으면**  
**`df4 = df4[['c', 'a', 'new']]` 이런식으로 다시 컬럼 설정을 해주면 된다.**  





