# 220302 Python 강의 (2) Container

여러 개의 값(객체)을 저장할 수 있는 것을 의미하며, **서로 다른 자료형**을 저장할 수 있다.

컨테이너는 아래의 두 가지로 분류할 수 있다.
 - 시퀀스(Sequence) 형 : 순서(ordered)가 있는 데이터
 - 비(Non-sequence) 시퀀스 형 : 순서(unordered)가 없는 데이터

---

## 시퀀스(Sequence)형 컨테이너

시퀀스(Sequence)는 데이터가 순서대로 나열된 형식을 나타낸다.

**주의! 순서대로 나열된 것이 정렬되었다(sorted)를 뜻하는 것은 아니다.**

순서대로 나열되었다 == 시퀀스가 있다 == *특정 위치의 데이터를 나타낼 수 있다*

### 리스트(List)

리스트는 대괄호 [] 및 list() 를 통해 만들 수 있다.

```python
my_list = []  # 무에서 유를 만들 때
another_list = list()  # 기존 데이터를 기반으로 리스트를 만들 때
```

주의 할 점은 아래와 같다.
- 변수명은 복수형으로 쓴다 ex) locations
- = (할당 연산자)의 앞, 뒤로는 띄어쓴다.
- , (trailing comma)의 뒤는 반드시 띄어쓴다. 
    - 마지막 요소 뒤에 , 를 빼먹는 경우 error 발생
    - 여러줄일 때 , 를 빼먹는 경우 error 발생

순서가 있는 Sequence는 인덱스(index)를 통해 접근 가능하다.
- 값에 대한 접근은 `list[idx]`의 형식으로 접근한다.

```python
boxes = ['apple', 'banana', ['apple', 'banana', 'cherry']]
print(boxes[2])

['apple', 'banana', 'cherry']
```

위의 코드 예시에서도 보이듯이, index는 0부터 시작한다. 

따라서 맨 마지막 요소를 출력하기 위해서는 n-1의 순서 지정이 필요하다.

### 튜플(Tuple)

튜플은 리스트(list)와 유사하지만, ()로 묶어서 표현한다.

주의할 점은 아래와 같다.
- 튜플은 수정 불가능(immutable)하다.
- 튜플은 직접 사용하기 보다는 파이썬 내부에서 암시적으로 사용되는 경우가 많다.
- 단일 항목을 가진 튜플의 경우 객체의 뒤에 ,(trailing comma)를 붙여야 튜플로 인식한다.  
단 복수 항목의 경우 생략 가능하다.

```python
tt = (1, 2, 3)

print(tt[0])  # 가능. 순서가 있기 때문에 idx 접근 가능하다.
tt[0] = 100  # 불가능. immutable하기 때문.
```

### 레인지(Range)

레인지는 정수의 시퀀스를 나타낼 때 사용한다.

- 기본형 : `range(n)`
    - 0부터 n-1까지의 값을 가짐.
- 범위 지정 : `range(n, m)`
    - n부터 m-1까지의 값을 가짐.
- 범위 및 스텝 지정 : `range(n, m, s)`
    - n부터 m-1까지 +s 만큼 증가한다.

튜플과 마찬가지로 idx는 접근 가능하지만, 수정불가능(immutable)하다.

### 패킹 / 언패킹 연산자(*) (Packing / Unpacking Operator)

- 모든 시퀀스형 (리스트, 튜플 등)은 패킹/언패킹 연산자 *를 사용하여 객체의 패킹 또는 언패킹이 가능하다. 

- 패킹의 경우, list로 대입하고,  
언패킹의 경우, tuple로 대입한다.

```python
def multiply(x, y, z):
    return x * y * z

numbers = [1, 2, 3]
print(multiply(numbers))  # multiply([1, 2, 3]) x자리에 이 리스트가 그대로 들어가버린다. 그리고 y와 z에는 할당 된 값이 없기 때문에 error 발생.
print(multiply(*numbers))  # multiply(1, 2, 3) 얘는 왜 될까? 압축 해제했으니까!

6
```

주의할 점은 아래와 같다.
- 대입문의 **좌변 변수**에 위치한다.
- 우변의 객체 수가 좌변의 변수 수보다 많을 경우 순서대로 대입한다.
- 나머지 항목들은 모두 * 표시된 변수에 대입한다.
- *연산자가 **곱셈**을 의미하는 연산자인지, **패킹/언패킹** 연산자인지 주의하여야 한다.
    - 패킹/언패킹 연산자의 경우
        - 대입식의 좌측에 위치하는 경우
        - 단항 연산자로 사용되는 경우 (하나의 항을 대상으로 연산이 이루어짐)
    - 산술 연산자의 경우
        - 이항 연산자로 사용되는 경우 (두 개의 항을 대상으로 연산이 이루어짐)

---

## 비 시퀀스(Non-sequence)형 컨테이너

### 세트(Set)

set는 순서가 없고, **중복된 값이 없는** 자료 구조이다.

- 세트는 수학에서의 집합과 동일하게 처리된다.
- 세트는 중괄호 {}를 통해 만든다.
- 담고 있는 객체를 삽입, 삭제 가능하다. (mutable)
- 빈 세트를 만들려면 set() 소괄호를 사용해야 한다. {} 사용 불가능.
- 세트 내에서 활용 가능한 연산자는 아래와 같다.
    - 차집합 (-)
    - 합집합 (|)
    - 교집합 (&)

```python
s1 = {1, 2, 3}
s2 = {3, 4, 5}

print(s1 - s2)  # s1과 s2의 차집합
{1, 2}

print(s1 | s2)  # s1과 s2의 합집합
{1, 2, 3, 4, 5}

print(s1 & s2)  # s1과 s2의 교집합
{3}

s3 = {1, 1, 1, 2, 3}  # set는 중복된 값이 존재하지 않는다.

print(s3)
{1, 2, 3}
```

### 딕셔너리 (Dictionary)

- {}와 dict()를 통해 만들 수 있다.
- 순서는 보장하지 않는다. (non-sequence)
- key는 **변경 불가능**하다. (immutable)
- key는 **중복된 값이 존재할 수 없다.**
- value는 list, dictionary를 포함한 모든 것이 가능하며, 변경 가능하다. (mutable)

```python
phone_book = {
    '서울': '02', 
    '부산': '051', 
    '대구': '053',
    '제주': '031', 
    '인천': '032', 
}

# key 뒤에는 띄어쓰기 없이 콜론(:)작성, value 전에는 띄어쓰기 필요!

# 접근 (key를 알고 있어야 함) 없는 키로 접근 시 에러
phone_book['서울']

# 수정 (key를 알고 있어야 함)
phone_book['서울'] = '022'

# 추가
phone_book['평양'] = '냉면'


# 변경 -> key가 이미 존재한다면 수정, key가 없었다면 추가
```

---

## 기타

### 컨테이너 형변환
range는 다 안되고, dictionary는 key만 가능하다고 봐도 무방하다.

### 멤버쉽 연산자 (Membership Operator)
in 연산자와, not in 연산자를 통해 요소가 시퀀스에 속해있는지 확인할 수 있다.

```python
'a' in 'apple'
True

'b' in 'apple'
False

'a' in {'A': 'a'}
False  # 왜냐하면 dictionary에서는 key값만 보기 때문.

1 in [1, 2, 3]
True
```

### 시퀀스형 연산자 (Sequence Type Operator)

#### 산술 연산자 (+)
시퀀스를 연결(concatenation)할 수 있다.

```python
[1, 2] + ['a']
[1, 2, a]

(1, 2) + ('a',)  # 단일 항목을 가진 튜플의 경우 ,(trailing comma) 작성 필요!
(1, 2, a)

# range는 error 발생.
```

#### 반복 연산자 (*)
시퀀스를 반복할 수 있다.

```python
[0] * 4
[0, 0, 0, 0]

(1, 2) * 3
(1, 2, 1, 2, 1, 2)

# range에는 사용할 수 없다.
# dictionary에는 사용할 수 없다. -> key 값이 중복될 수 있어서.
```

### 인덱싱 / 슬라이싱 (Indexing / Slicing)

#### 인덱싱 (Indexing)

시퀀스의 특정 인덱스 값에 접근 할 수 있다.

```python

range(3)[2]
2

'abc'[0]
'a'

'apple'[100]
Error  # 100번째 값이 없으니까.
```

#### 슬라이싱 (Slicing)

시퀀스를 특정 단위로 슬라이싱 할 수 있다.

```python
list(range(1, 10, 2))
[1, 3, 5, 7, 9]

'''
[시작:끝:스텝]에서 [x:y:z]라고 할 때, 
[x:y] : x <= idx < y 이며, z = 1
[x:] x <= idx < 길이
[:y] 0 <= idx < y
[:] 0 <= idx < 길이
[::-1] range를 거꾸로

''' 
# y 미만이라는 거를 기억하기!

print([1, 2, 3, 4][1:4])  # 4번째 인덱스가 없어도 계산 가능하다.
print((1, 2, 3)[:2])  
print(range(10)[5:8])
print('abcd'[2:4])  # slice 마지막 인덱스가 더 크더라도, 에러가 발생하지 않는다.

[2, 3, 4]
(1, 2)
range(5, 8)
cd

s = 'abcdefghi'

s[2:5]
'cde'

s[::-1]
'ihgfedcba'

s[:4]
'abcd'
```

로또 번호 추첨도 가능하다.

```py
'''
1 ~ 45 자연수 중 랜덤하게 6개를 추출한다

1. 1 ~ 45 자연수
2. 랜덤 추출기
'''

import random

random.sample(range(1, 46), 6)

```















