# Computational Thinking - 프로그래밍과 논리/수학

SW Expert Academy의 Computational Thinking 강좌를 들으며 배운 내용을 기록한다. 

프로그래밍은 어렵다.  
왜 어렵다고 느낄까?   
크게 두 가지의 이유로 나눠볼 수 있다. 

1. 프로그래밍 문법 및 라이브러리 사용
2. 논리 (Hard Logic)

1번의 경우에는, 우리가 원래 모르고 있는 걸 배우는 것이기 때문에 훈련의 필요성에 크게 반감을 가지지 않고, 학습과 능력의 상승이 비례한다는 점이 있다.  

하지만 2번의 경우에는, 유저에게 크게 어렵게 와닿지 않는다.  
우리가 일상생활에서도 '논리'를 사용하기 때문.

---

## 논리와 증명

<카드 문제>
- 사실 : 모든 카드의 한쪽에는 알파벳, 다른 쪽에는 숫자
- 주장 : 만약, 한쪽이 D이면, 반대쪽은 3
- 문제 : 주장이 사실인지 확인하기 위해 아래 카드 중 반드시 뒤집어 봐야 하는 카드는 몇 개이고 어느 것인가? 

카드 : [D], [F], [3], [7]

정답 : [D]와 [7]

[F]가 답이 아닌 이유는 뒷면에 3이 오던, 무엇이 오던 상관 없기 때문.  
[7]이 답이 아닌 이뉴는 뒷면에 D가 오던, 무엇이 오던 상관 없기 때문.

그렇지만, [7]뒤에 D가 적혀있다면, 주장은 거짓이 되기 때문에 반드시 뒤집어봐야 한다. 

이와 비슷한 예시로 맥주집 문제도 있다.  
맥주집 문제는 카드 문제와 논리 구조는 똑같지만, 훨씬 풀기 쉽다.   
왜냐하면 **직관**을 이용해서 풀었기 때문.  

직관이란, 논리적인 **느낌**을 주는 것이다.  
직관의 장점은 익숙한 상황에서 빠르다는 것이고,   
단점은 정확하지 않다는 것과, **강한 착각을 일으킨 다는 것**이다.

* "너 과자 몇 개 먹었니?" vs "버스 타려고 하는데 천원 있니?"  

두 질문은 같은 표현을 사용하지만,  
하나는 정확한 개수를 요구하고,  
다른 하나는 천원 이상이 있는 지 물어보는 것이다. 

* "합격하려면 토플 500점 이상 혹은 토익 600점 이상이 필요" vs "복권에 당첨되면 자동차 혹은 천만원을 줍니다."  

마찬가지로 두 질문은 같은 표현을 사용하지만,  
하나는 inclusive, 다른 하나는 exclusive이다.  

이렇게 직관은 Soft Logic의 영역에 속해있는데,  
일상생활에서는 Soft Logic이 빠르기 때문에 유용하다.  
논리적으로는 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 포함되어 있다. 

하지만, **프로그래밍은 Hard Logic을 사용한다.**  
프로그래밍 언어의 표현들이 모두 논리학에서 나왔고,  
사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요하다. 

~~알고리즘이 어려운 이유는, Sotf Logic으로 알고리즘을 이해하려고 하는 것!~~  

<논리 연습>

Q : 다음을 명제식 형태로 쓰고 참인지 거짓인지 판단하시오.
1. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다. 
2. 만약 19892827938274839이 Prime Number라면, 2는 짝수이다. 

* 1번 문제 풀이 :  
미국에서 2080년에 월드컵이 열릴지 안열릴지는 아무도 모른다.  
하지만, 전체 명제가 참인지 거짓인지는 판단할 수 있다. 왜냐하면 0이 홀수가 아니기 때문이다.  
0이 홀수가 아니기 때문에, 즉 가정이 거짓이기 때문에 전체 명제는 참이 된다.  

**'P이면 Q이다'의 명제에서 P(가정)가 거짓이면 전체 명제는 참이다.** 

이해가 안된다면, 아래의 예시를 참고하자.  

아버지가 시험에서 100점을 받으면, 치킨을 사주겠다고 약속하셨다.  
- 시험에서 100점을 받았는데, 아버지가 치킨을 사주셨다. -> 약속을 지킨 것.
- 시험에서 100점을 받았는데, 아버지가 치킨을 사주지 않으셨다 -> 약속을 어긴 것.
- 시험에서 80점을 받았는데, 아버지가 치킨을 사주지 않으셨다. -> 약속을 지킨 것.
- 시험에서 80점을 받았는데, 아버지가 치킨을 사주셨다. -> 약속을 지킨 것.

약속을 지켰다기 보다는, 약속을 어긴 것이 아니라는 말이 옳다.  

즉 가정이 거짓이라면, 전체 명제는 참이 되는 것이다. 

* 2번 문제 풀이 : 
저 숫자가 소수인지 아닌지 계산해보지 않는 이상은 모른다.  
하지만 2가 짝수인 것은 참이기 때문에, 전체 명제는 참이 된다.  

**'P이면 Q이다'의 명제에서 Q가 참이면 전체 명제는 참이다.** 

Q : p와 q가 명제이고, p -> q(p이면 q이다)가 거짓이라고 하자.  
다음 명제식의 참 거짓은 어떻게 되는가?
1. ~p -> q 
2. p V q
3. q -> p

위의 논리를 적용해서 풀어보면, p -> q가 거짓이 되는 경우는 한 가지 밖에 없다.  
p가 참이고, q가 거짓일 경우이다.

그렇다면 1번은 가정이 거짓이니 전체 명제는 참이 되고,  
2번은 p or q이니, p가 참이기 때문에 당연히 결과는 참이 된다.  
3번은 q가 거짓이기때문에 전체 명제는 참이 된다.  

Q : 위의 명제들의 역, 이, 대우를 쓰시오.

- 역 = P와 Q의 위치 리버스
    - 미국에서 2080년 월드컵이 열린다면, 0이 홀수이다.
    - 2가 짝수라면, n은 소수이다.
- 이 = ~P와 ~Q
    - 만약 0이 홀수가 아니라면, 미국에서 2080년 월드컵이 열리지 않는다.
    - 만약 n이 소수가 아니라면, 2는 짝수가 아니다.
- 대우 = ~Q와 ~P
    - 만약 미국에서 2080년 월드컵이 열리지 않는다면, 0은 홀수가 아니다.
    - 만약 2가 짝수가 아니라면, n은 소수가 아니다.

Q : 다음 명제식의 진리표를 만드시오.
1. p^(q -> p)
2. (p^~q) -> r

* 1번 문제 풀이:  
p q : p^(q -> p)  
T T : F  
T F : T  
F T : F  
F F : F

* 2번 문제 풀이:  
p q r : (p^~q) -> r   
T T T : T  
T T F : T  
T F T : T  
T F F : F  
F T T : T   
F T F : T  
F F T : T  
F F F : T  

증명은 정확한 명제식으로 표현할 수 있는 것이라야 함.  
보통은 정확한 명제식까지 쓰지는 않으나 근본적으로는 명제식으로 바꿀 수 있음.  
증명에 대한 수많은 오해가 p -> q를 p <-> q (p이면 q이고, q이면 p이다. 즉, p와 q의 진리값이 같다)와 혼동하는 것에서 일어난다.  

<당구공 Paradox>

모든 당구공은 색이 같다는 것을 증명하려 하는 과정에서 잘못된 점을 고르는 문제.  

- 수학적 귀납법: p(1)이 참이고, p(n) -> p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다. 
- p(1): 당구공 1개가 들어있는 집합은 모두 색이 같다. 
- p(n) -> p(n+1)을 증명하기 위해 p(n)이 참이라고 가정. 
- 당구공 n+1개가 들어있는 임의의 집합을 생각함.
- 이 집합에서 하나를 빼면 당구공 n개가 있는 집합이 되므로 지금 상황에서 모든 당구공의 색이 같음.
- 방금 뺀 당구공을 다시 넣고, 다른 당구공을 배면 역시 당구공 n개가 있는 집합이 되므로 지금 상황에서도 모든 당구공의 색이 같음.
- 위의 상황에서 처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같음을 알 수 있으므로 당구공 n+1개가 들어있는 임의의 집합은 색이 같은 것만을 포함한다.


대부분의 경우, p(n)이 참이라고 가정할 수 없다고 반론한다.  
하지만, p(n)이 참인지는 이 명제에서 중요하지 않다! 거짓이어도 이 명제는 무조건 참이기 때문. 

위의 증명에서 잘못된 부분은 **처음 뺀 당구공과 두번째로 뺀 당구공의 색이 같은 지 알 수 없다는 것이다.**

p(1) -> p(2)를 생각해보면 쉽다.  
공이 2개만 있으면, 하나를 뺐을 때, 나머지 공이 하나만 있기 때문에 참이 되는 것이고,  
다시 뺀 공을 집어 넣고 원래 있던 공을 뺐을 때도 공이 하나만 있기 때문에 참이 되는 것이지, 이 두 개의 공이 같은 색깔인지는 알 수 없다.  

<`Infintiely Many Prime Numbers>

- 소수의 개수가 유한한 k개라고 가정
- 모든 소수를 다 곱하고 1을 더한 수를 n이라고 하자
- n은 어떤 소수로 나누어도 나머지가 1이다
- 그런데 n은 어떤 소수보다도 크므로 합성수이다.
- 합성수이지만 어떤 소수로도 나누어지지 않으므로 모순 발생

위의 증명에 대한 반론으로 몇 개의 소수가 더 존재하면 되는 것이 아니냐는 반론이 있다.  
이 반론은 '소수가 k개이면 모순이 발생'  
즉, 소수가 k개이면 -> 항상 거짓이다. 이 명제가 항상 참임을 확인 한 것이다.  
즉, '소수가 k개'라는 명제가 항상 거짓일 수 밖에 없다.  

즉, **소수가 유한한 k개가 아니라, 무한히 있다는 것을 증명**할 수 있다. 

<수학적 귀납법>

- 수학적 귀납법의 기본형: p(1)이 참이고, p(n) -> p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다.
- 수학적 귀납법의 강한 형태: p(1)이 참이고, p(1)^p(2)^p(3)^...^p(n) -> p(n+1)이 참이면 p(n)은 모든 자연수 n에 대해서 참이다.

`if (x <= 0) return 0;
return x + sum(x-1);`

High-level 증명에서는 1부터 x까지 합의 정의 중 하나인 S(n) = S(n-1) + n을 그대로 코딩한 것이므로 증명이 된 것이라고 말하는 경우가 많다.  
하지만, 상세한 증명을 하려면 단순히 답이 맞는 것이 *당연하다*라고 말하는 것으로는 충분하지 않다. 

즉, 증명이 가능한 명제를 만들어야 한다.  
이 경우 증명이 가능한 명제는 아래와 같다.  
**"sum(x)가 리턴하는 값은 1+2+3+...+x의 값과 항상 같다"**

이제 수학적 귀납법을 적용할 수 있다.  
- p(1)이 참이다: 'sum(1)이 리턴하는 값이 1이다'를 증명하면 된다. 실제 코드에 1을 대입하면 1을 리턴함을 알 수 있다.
- p(x) -> p(x+1)이 참이다: 'sum(x-1)이 1+2+...+(x-1)을 리턴하면 sum(x)는 1+2+...+x를 리턴한다'를 증명하면 된다. 
- 코드를 보면 sum(x)는 x+sum(x-1)의 값을 리턴한다. sum(x-1)의 리턴 값은 1+2+...+x-1과 같다고 가정했으므로 sum(x)는 1+2+...+x를 리턴함을 확인할 수 있다.  

*즉, 코드를 짤 때 sum(x-1)이 제대로 된 값인지 생각할 필요가 없다.  
sum(x-1)은 참이라고 가정하고, 그 상태에서 sum(x)만 참인지 거짓인지를 보면 된다.*




